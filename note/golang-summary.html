<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golang学习杂记 - 小V吃鱼卡到了</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="http://www.zhuimengle.com/theme/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css" />
    <link rel="stylesheet" href="http://www.zhuimengle.com/theme/css/niu2.min.css" type="text/css" />

    <link rel="canonical" href="http://www.zhuimengle.com/note/golang-summary.html" />
    
    <script type="text/javascript">window.onload=function(){};</script>
    <!--[if lt IE 9]>
        <script src="http://www.zhuimengle.com/theme/js/html5shiv.js"></script>
        <script src="http://www.zhuimengle.com/theme/js/respond.min.js"></script>
    <![endif]-->
  </head>
  <body> 
    <div id="body-header">
<div class="navbar navbar-inverse navbar-fixed-top">
<div class="col-md-12">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://www.zhuimengle.com">
            <i class="fa fa-home"></i>小V吃鱼卡到了
        </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
        <ul class="nav navbar-nav">
            <li><a href="/about.html" title="about me">
                <i class="fa fa-anchor"></i>关于</a>
            </li>
            <li><a href="/agreement.html" title="agreement">
                <i class="fa fa-info-circle"></i>使用协议</a>
            </li>
            <li><a href="/my_projects.html" title="my projects">
                <i class="fa fa-rocket"></i>项目</a>
            </li>
            <li><a href="/archives.html" title="blog archives">
                <i class="fa fa-archive"></i>存档</a>
            </li>
            <li><a href="/tag/" title="blog tags">
                <i class="fa fa-tag"></i>标签</a>
            </li>
        <!-- category dropdown list -->
        <li class="dropdown">
           <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                <i class="fa fa-folder-open"></i>分类<b class="caret"></b>
           </a>
           <ul class="dropdown-menu">
               <li><a href="http://www.zhuimengle.com/note/index.html">
                      <i class="fa fa-book"></i>印象-笔记
                      (88)</a></li>
               <li><a href="http://www.zhuimengle.com/research/index.html">
                      <i class="fa fa-flask"></i>实验室
                      (2)</a></li>
           </ul>
        </li>
        <!--  self defined dropdown list -->
        </ul>
        
        <!-- right nav bar -->
        <ul class="nav navbar-nav navbar-right">
        <!-- google custom search -->
       </ul>
    </nav>
</div>
</div>    </div>
    
    <div id="body-content">
<div class="col-md-8 col-md-offset-2">
    <h1 id="content-heading">Golang学习杂记</h1>
</div>
<div id="niu2-left-container" class="col-md-6 col-md-offset-2 with-right-border">
    <div id="niu2-main-content">
        <p>记录Golang的一些关键语法和易错易混淆的知识点。以下内容均基于Linux x86-64平台下的Go1.2，其中可能有错漏之处，欢迎反馈。</p>
<h2 id="85e90215e2220188b57f612e49a2bf44">开发环境和工具</h2>
<p>升级Go之前，必须先移除旧的版本。</p>
<h3 id="3867e350ebb33a487c4ac5f7787e1c29">环境变量</h3>
<p>Go开发涉及的环境变量有两个:</p>
<ul>
<li><code>GOROOT</code>: go的安装目录，类似于Java的<code>JAVA_HOME</code>变量。</li>
<li><code>GOPATH</code>: go的工作目录，所有通过<code>go get</code>下载的第三方库都会位于该目录下。</li>
</ul>
<p>然后设置<code>PATH</code>变量:</p>
<div class="codehilite"><pre>export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
</pre></div>


<h3 id="456f94c1a28382c25e09ff39504347c1">编译器版本</h3>
<p>golang的编译器有如下几个版本：</p>
<ul>
<li><a href="http://golang.org/cmd/6g/">6g</a>: x86-64架构(64位操作系统)上使用的编译器</li>
<li><a href="http://golang.org/cmd/8g/">8g</a>: x86架构(32位操作系统)上使用的编译器</li>
<li><a href="http://golang.org/doc/install/gccgo">gccgo</a>: GCC的前端，有些时候用gccgo编译出的可执行程序比6g和8g编译出的要快几倍。</li>
</ul>
<h3 id="8998c0f7f7aefaebad989aef6dfdab25">辅助工具</h3>
<ul>
<li><code>go tool pprof</code>: profiling工具，参考文章<a href="http://blog.golang.org/profiling-go-programs">Profiling Go Programs</a>。</li>
<li><code>gofmt</code>: 格式化go源码。<div class="codehilite"><pre>find . -name &quot;*.go&quot; | xargs gofmt -w
</pre></div>


</li>
</ul>
<h2 id="c6e79d0b821860da1d6187fac8338d5a">语法总结</h2>
<h3 id="488415410b3845655feeefc5207b5c06">0值</h3>
<p>Zero value</p>
<ul>
<li>boolean: <code>false</code></li>
<li>integer: <code>0</code></li>
<li>float: <code>0.0</code></li>
<li>string: <code>""</code></li>
<li>pointer, function, interface, slice, channel, map: <code>nil</code></li>
</ul>
<h3 id="91414d4d32a791d88b9bec749632987a">值传递</h3>
<p><strong>Everything</strong> in Go is passed by value<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>。</p>
<h3 id="7df6e743c28cabad3cac4deba9b16ef5">引用类型</h3>
<p>pointer, slice, channel和map均可看作引用类型，发生值拷贝时，被拷贝的仅仅是指向实际数据的指针<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>。</p>
<h3 id="ef1465c397cb0afb57238359060065fb">range表达式</h3>
<p>range表达式仅在循环开始前执行一次<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>，每次循环的迭代都会对左边的迭代变量赋一次值<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>，因此在循环中对迭代变量的修改不会影响到其他的迭代。</p>
<div class="codehilite"><pre>a := []int{ 1, 2, 3 }
for i, v := range a {
    println(i)
    i -= 1
}
</pre></div>


<p>输出<code>1 2 3</code>(省略了换行符)。</p>
<h3 id="00684cc251d8c2e4a870aa00128dc1ff">数组和slice</h3>
<h4 id="f45a735ab3f170d38481359f09ac511e">数组类型</h4>
<ol>
<li>数组的长度也是其类型的一部分，<code>[3]int</code>和<code>[4]int</code>类型不同。</li>
<li>和slice不同，发生值拷贝时，数组的所有数据都会被拷贝。</li>
</ol>
<h4 id="b004d7060310612fc2a5e970bbbbe32d">slice和数组的定义</h4>
<div class="codehilite"><pre>sl := []int{1, 2, 3}
ar := [3]int{1, 2, 3}
</pre></div>


<p>上面的代码中，sl是长度和容量均为3的slice，ar是长度为3的数组。</p>
<h4 id="b5d9f3bbb944447754f85a27d68a9ed1">slice和append</h4>
<p>使用append时，如果slice对应的array的长度不够，go会创建一个新的array以容纳新添加的数据，所有旧的array数据都会被拷贝到新的array里。需要频繁使用append时，需要考虑到其效率问题。</p>
<p>对于数据量已知且每次append一条数据的情况，推荐如下使用方式。</p>
<div class="codehilite"><pre>// 初始化一个长度为10的数组
sourceArray := [5]int{ 1, 2, 3, 4, 5}
// 初始化一个长度和容量均为10的slice
targetSlice := make([]int, len(sourceArray))
// 使用range遍历数组，注意不使用第二个返回值以避免额外的拷贝开销
for i := range sourceArray {
    // 依次在目标slice的i位置插入数组的对应元素
    targetSlice = append(targetSlice[:i], sourceArray[i])
}
</pre></div>


<h4 id="3b21f3d5af918439f866b01a858c5f00">slice和数组访问越界</h4>
<p>以下是常见的使用场景和常见的错误：</p>
<div class="codehilite"><pre>ar := [3]int{1, 2, 3} // len(ar) == 3
sa := ar[:]           // len(sa) == 3
sb := ar[:2]          // len(sb) == 2

ar[3:] // []
sa[3:] // []
sb[2:] // panic

ar[4:] // compiler error
sa[4:] // panic 访问越界
sb[3:] // panic 访问越界
</pre></div>


<p>超过slice长度的元素，即使slice指向的数组里存在该元素，使用slice访问依然会越界。</p>
<div class="codehilite"><pre>ar[3]  // == 3
sb[3]  // panic error
</pre></div>


<h3 id="6b46a1cba807f97ed4a145f731fd9cec">string类型</h3>
<p>string使用UTF-8编码。</p>
<h3 id="1d78dc8ed51214e518b5114fe24490ae">map</h3>
<div class="codehilite"><pre>value, found := MapABC[key]
</pre></div>


<p>上面的代码中，value依然是map中key对应的值的拷贝。如果不使用第二个参数found，如下</p>
<div class="codehilite"><pre>value := MapABC[key]
</pre></div>


<p>则当key不存在时，value被初始化为对应的0值。</p>
<h3 id="2cb472ff9cad0c89a033c53996b52053">初始化</h3>
<p>常见的初始化方法。</p>
<ol>
<li>new初始化变量为0值，返回指针。</li>
<li>构造函数，使用<code>&amp;</code>可返回指针，成员的默认值为0值。</li>
<li>make仅用于初始化slice, map和channel三种类型，返回实际变量。</li>
<li>源文件中的init函数，所有的init函数按引用顺序在程序运行后依次执行，参考<a href="http://golang.org/ref/spec#Program_execution">这里</a>。</li>
</ol>
<h3 id="441add7be9dc2782ccd5f8594f9d0f3c">赋值操作符</h3>
<p>使用<code>:=</code>需要注意的地方。</p>
<ol>
<li>左边的成员至少要有一个是未声明的变量。</li>
<li>已声明的变量，在同一作用域内，变量值被改写。</li>
<li>如果已声明的变量作用域在外层，则定义一个新的同名变量，会屏蔽外层的变量。</li>
</ol>
<h3 id="57e5fba4ce5b4cb9ffd595beb63e7389">iota</h3>
<p>每个const关键字都会将iota的值重置为0，每个const表达式让iota增加1。</p>
<div class="codehilite"><pre>const m = iota // m = 0
const n = iota // n = 0

const (
    a = iota   // a = 0
    b = iota   // b = 1
    c          // c = 2
)

const (
    d = 1 &lt;&lt; iota // iota重置为0，d = 1
    e             // e = 1 &lt;&lt; 1 = 2
    f             // f = 1 &lt;&lt; 2 = 4
)
</pre></div>


<p>在同一个const表达式中多次使用iota，其值不变。</p>
<div class="codehilite"><pre>const (
    a, b = iota, 1 &lt;&lt; iota // a = 0, b = 1
    c, d                   // c = 1, d = 2
    e, f                   // e = 2, f = 4
)
</pre></div>


<h3 id="d3c0b3ea82a4a103b38d5e32d4fb4be2">函数参数和命名的返回变量</h3>
<ul>
<li>函数参数和命名的返回变量的作用域就是函数体。</li>
<li>命名的返回变量默认值为0值，一个单独的<code>return</code>会返回命名的返回值的当前值。</li>
</ul>
<h3 id="870a51ba2a9edfadc62ce99af52cabd1">函数</h3>
<p>函数可以作为值附给变量，代码见<a href="http://play.golang.org/p/DABfLTIDIm">这里</a>。</p>
<div class="codehilite"><pre>package main

func test(a int) int {
    return a
}

func main() {
    var fun func(int)int = test
    println(fun(100))
}
</pre></div>


<h3 id="68a6605ba63cdd2bd0ef3e5c15dee2ab">vector容器</h3>
<p>Go1删除了vector容器<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>，所有的vector操作均可通过slice配合一定的技巧实现，具体请参考<a href="https://code.google.com/p/go-wiki/wiki/SliceTricks" title="golang slice tricks">Slice技巧</a>。</p>
<h3 id="0db23960de47f2f31acde25853062bdf">返回临时变量的指针</h3>
<p>在Golang里，返回临时变量的指针是完全合法的，比如下面的函数。</p>
<div class="codehilite"><pre>func test() *int {
    a := 5
    return &amp;a
}
</pre></div>


<p>原因在于，对于使用<code>&amp;</code>符号取址的变量，go编译器将其分配到heap上。进一步阅读可参考<a href="http://golang.org/doc/faq#stack_or_heap">faq: stack or heap</a>和<a href="http://www.scvalex.net/posts/29/" title="Escape Analysis in Go">Escape Analysis in Go</a>。</p>
<h2 id="dd970a1f2394462211025da6a66ca504">标准库</h2>
<h3 id="ac5c74b64b4b8352ef2f181affb5ac2a">sql</h3>
<p>Open()返回的<code>type DB</code>是一个数据库的句柄，而不是一个数据库连接，另外Open函数也不一定立即建立和数据库的连接（见Open函数的说明）。</p>
<p><code>type DB</code>维护着一个数据库连接池，在多个goroutine之间并发使用是安全的。由于连接池的存在，每次执行Query()和Exec()等函数的并不一定是同一个数据库连接，因此如果有需要，可以使用Begin()函数创建一个数据库事务，在Begin()和Commit()/Rollback()之间的数据库操作将被保证在同一个数据库连接上执行。</p>
<p>基于以上的事实，每次数据库请求都调用Open()和Close()是不明智甚至是不正确的。</p>
<h3 id="4fe3e66b2026c6f3d9514fd8f6cf6668">gob</h3>
<p>gob.Encode(a interface{})，如果a保存的是指针类型，实际编码的是a所指向的数据。</p>
<p>引用一，<a href="http://blog.golang.org/gobs-of-data">http://blog.golang.org/gobs-of-data</a></p>
<blockquote>
<p>This flexibility also applies to pointers. Before transmission, all pointers are flattened. Values of type int8, <em>int8, <strong>int8,<strong><em><em>int8, etc. are all transmitted as an integer value, which may then be stored in int of any size, or </em>int, or </em></strong></strong></em>int, etc. </p>
</blockquote>
<p>引用二，<a href="http://golang.org/pkg/encoding/gob/">http://golang.org/pkg/encoding/gob/</a></p>
<blockquote>
<p>Pointers are not transmitted, but the things they point to are transmitted; that is, the values are flattened. Recursive types work fine, but recursive values (data with cycles) are problematic. <strong>This may change</strong>.</p>
</blockquote>
<h3 id="07cc694b9b3fc636710fa08b6922c42b">time</h3>
<p>涉及到时区的常用函数：</p>
<ul>
<li>LoadLocation: 根据时区的名称获取对应的Location，时区名称可参考<a href="http://en.wikipedia.org/wiki/List_of_tz_database_time_zones">List of tz database time zones</a>，文档见<a href="http://golang.org/pkg/time/#LoadLocation">此</a>。</li>
<li>In(Location): 将time转换为Location所在的时区，返回转换后的time，文档见<a href="http://golang.org/pkg/time/#Time.In">此</a>。</li>
</ul>
<h3 id="10ae9fc7d453b0dd525d0edf2ede7961">list</h3>
<p>golang的list实现了一个双向链表<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>，不适合随机存取(按索引取值)，不是goroutine安全的。相比slice，list适合用在需要频繁在首尾插入元素或删除某个元素的情况。</p>
<h2 id="80cf5376b8c199b39a1778688720470e">疑难问题</h2>
<h3 id="f733ee949a16cd4add143a9c0d13302c">在循环中删除slice的元素</h3>
<p><span class="alert-danger">
不要这么做，考虑用<a href="#10ae9fc7d453b0dd525d0edf2ede7961">list</a>替换slice。
</span></p>
<div class="codehilite"><pre>a := []int { 1, 2, 4, 5 }
println(len(a)) // 4
println(a[4:])  // []
println(a[5:])  // panic
</pre></div>


<p>以上是一些关于slice的基础知识，下面举个循环中删除slice元素的例子。假设我们有如下一个需求：</p>
<blockquote>
<p>给定一个slice []int{1, 2, 4, 5}，我们希望通过一个for循环删除其中的偶数元素，期望的输出是1, 5。</p>
</blockquote>
<p>以下的代码会直接panic，原因是在第4次迭代的时候，发生了slice访问越界(此时slice长度为3, i为3)，完整代码见<a href="http://play.golang.org/p/85hbFJgWGz">这里</a>。</p>
<div class="codehilite"><pre>a := []int{1, 2, 4, 5}
for i, _ := range a {
    if a[i]%2 == 0 {
        // delete a[i]
        a = append(a[:i], a[i+1:]...)
    }
}
fmt.Println(a)
</pre></div>


<p>以下的代码不会panic，但结果不是我们期望的。完整代码见<a href="http://play.golang.org/p/o8-OrdSVfH">这里</a>:</p>
<div class="codehilite"><pre>s := []int{1, 2, 4, 5}
for i := 0; i &lt; len(s); i++ {
    if s[i]%2 == 0 {
        // delete s[i]
        s = append(s[:i], s[i+1:]...)
    }
}
fmt.Println(s)
</pre></div>


<p>输出<code>[1 4 5]</code>。</p>
<p>原因在于删除第二个元素<code>2</code>之后，目标slice变为了<code>[]int{1, 4, 5}</code>，而此时i为1，下一次迭代i自增后直接略过了<code>4</code>。解决方案是在删除过后，将i减1。如下，完整代码见<a href="http://play.golang.org/p/3sxuJfcCVa">这里</a>:</p>
<div class="codehilite"><pre>s := []int{1, 2, 4, 5}
for i := 0; i &lt; len(s); i++ {
    if s[i]%2 == 0 {
        // delete s[i]
        s = append(s[:i], s[i+1:]...)
        i -= 1
    }
}
fmt.Println(s)
</pre></div>


<h3 id="c9df09b4610bb43e290507a37c658ae8">defer</h3>
<p>以下参考了文章<a href="http://bbs.mygolang.com/thread-406-1-1.html" title="你真的懂defer了吗">《你真的懂defer了吗》</a>中的代码。</p>
<p>例子1，见<a href="http://play.golang.org/p/wY8p-jY0ex">这里</a>，输出1。</p>
<div class="codehilite"><pre>package main

func fun() (m int) {
    defer func() {
        m++
    }()
    return 0
}

func main() {
    println(fun())
}
</pre></div>


<p>defer在return之前执行，但return并非原子操作。具体的说return分两步，首先为返回变量赋值<code>m = 0</code>，然后空返回<code>return</code>。 而实际上defer在这两步之间被执行，即先给返回变量赋值，然后执行defer语句，最后一个空的return语句，因此上面的函数可改写为：</p>
<div class="codehilite"><pre>func fun() (m int) {
    m = 0 // 返回变量赋值
    m++ // defer
    return
}
</pre></div>


<p>另外一个例子，见<a href="http://play.golang.org/p/8mBfLOYMPk">这里</a>，输出5。</p>
<div class="codehilite"><pre>package main

func fun() (r int) {
    t := 5
    defer func() {
        t = t + 5
    }()
    return t
}

func main() {
    println(fun())
}
</pre></div>


<p>上面的fun函数可改写为：</p>
<div class="codehilite"><pre>func fun() (r int) {
    t := 5
    r = t
    t = t + 5
    return
}
</pre></div>


<h3 id="22a13315ec051c29264322c186236635">无法获取map元素的地址</h3>
<p>代码见<a href="http://play.golang.org/p/J4eOCvSKn-">这里</a></p>
<div class="codehilite"><pre>package main

type A struct {
    Value int
}
func (a A) getVal() int {
    return a.Value
}
func (a *A) getVal2() int {
    return a.Value
}

func main() {
    a := map[int]A{ 1: A{10} }

    //println(&amp;a[1])          // wrong, cannot take the address of a[1]

    println(a[1].Value)       // ok
    //a[1].Value = 20         // wrong, cannot assign to a[1].Value

    println(a[1].getVal())    // ok
    //println(a[1].getVal2()) // wrong, cannot call pointer method on a[1]; cannot take the address of a[1]
}
</pre></div>


<p>分别取消注释的代码并运行可看到相应的编译错误，总之就是map的index操作获得的变量无法取其指针。</p>
<p>另一段代码，见<a href="http://play.golang.org/p/QAShQtVyO1">这里</a></p>
<div class="codehilite"><pre>package main

type A struct {
    Value int
}

func main() {
    a := map[int]A{ 1: A{10} }
    b := map[int]int{ 1: 10 }

    //a[1].Value += 10 // error, cannot assign to a[1].Value
    b[1] += 10

    println(a[1].Value)
    println(b[1])
}
</pre></div>


<p>取消注释的行并运行可看到注释后的编译错误，原因我暂时也不清楚。</p>
<p>解决的方法主要有两个，在map的值使用指针类型(*A)，代码见<a href="http://play.golang.org/p/omlBnBZYfT">这里</a>。</p>
<div class="codehilite"><pre>package main

type A struct {
    Value int
}

func main() {
    a := map[int]*A{ 1: &amp;A{10} }

    a[1].Value += 10

    println(a[1].Value)
}
</pre></div>


<p>或者使用一个临时变量，代码见<a href="http://play.golang.org/p/-gBUhLGIXN">这里</a>。</p>
<div class="codehilite"><pre>package main

type A struct {
    Value int
}

func main() {
    a := map[int]A{ 1: A{10} }

    tmp := a[1]
    tmp.Value += 10
    a[1] = tmp

    println(a[1].Value)
}
</pre></div>


<p>关于此问题的讨论链接:</p>
<ul>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/V_5kwzwKJAY">golang-nutes&gt;Address of map entries</a></li>
<li><a href="https://groups.google.com/forum/?fromgroups=#!topic/golang-nuts/4_pabWnsMp0">golang-nuts&gt;Why can't I assign to struct in map?</a></li>
<li><a href="https://code.google.com/p/go/issues/detail?id=3117">go issue: spec: cannot assign to a field of a map element directly: m["foo"].f = x</a></li>
</ul>
<h3 id="5fc0efe228c120dd03db2c361dd0865b">for循环变量重复使用问题</h3>
<p>示例代码如下，见<a href="http://play.golang.org/p/F-Y1Jgt9t8">这里</a>，输出<code>3 3 3</code>。</p>
<div class="codehilite"><pre>package main

import &quot;time&quot;

func main() {
    for _, a := range []int{1, 2, 3} {
        go func() {
            println(a)
        }()
    }
    time.Sleep(2)   
}
</pre></div>


<p>原因是Golang的for循环会在各个迭代中重复使用循环变量，通常不会有问题，但是结合goroutine使用会有错，详细内容可参考<a href="http://golang.org/doc/effective_go.html#channels">Effective Go#Channels</a>中的相关解释。</p>
<p>要想输出<code>1 2 3</code>而不是<code>3 3 3</code>，解决方法是在每次迭代中使用循环变量的拷贝值。</p>
<div class="codehilite"><pre>for _, a := range []int{1, 2, 3} {
    go func(val int) {
        println(val)
    }(a)
}
</pre></div>


<p>或者</p>
<div class="codehilite"><pre>for _, a := range []int{1, 2, 3} {
    a := a
    go func() {
        println(a)
    }()
}
</pre></div>


<h2 id="3ba34fc6491df1c7ab2d294d7a12417d">书籍推荐</h2>
<h3 id="ec1633e5db8e388725ff9d9be144e42c">Go学习笔记 By雨痕</h3>
<p>这其实是人家的学习笔记，内容详细且全面，非常适合通读。</p>
<h2 id="2053d42c819811d6f43bd3305fe60447">其他资源</h2>
<ul>
<li><a href="http://play.golang.org/">Go Playground</a> 方便共享golang的代码，向别人请教问题时尤其有用。</li>
</ul>
<h2 id="bf52b411fae5afe9115f14123f776321">其他问题</h2>
<h3 id="e7040dd1bcab98d06aa49c5062f122ca">动态链接</h3>
<p>众所周知，除了用<a href="http://golang.org/cmd/cgo/">cgo</a>链接的c动态库之外，golang库都是被静态链接到可执行文件的。对于没有动态链接这个特性，官方貌似一直没有给出具体解释，目前看来估计以后也不会实现。</p>
<h2 id="81f5d554d30e82d475ed29a45a7c4277">阅读资料</h2>
<ol>
<li><a href="http://golang.org/doc/effective_go.html">Effective Go</a></li>
<li><a href="http://golang.org/ref/spec">The Go Programming Language Specification</a></li>
<li><a href="http://golang.org/doc/faq">Golang Frequently Asked Questions (FAQ)</a></li>
<li><a href="http://www.scvalex.net/posts/29/" title="Escape Analysis in Go">Escape Analysis in Go</a></li>
<li><a href="http://bbs.mygolang.com/thread-406-1-1.html" title="你真的懂defer了吗">你真的懂defer了吗</a></li>
<li><a href="http://blog.golang.org/gobs-of-data">Gobs of data</a></li>
<li><a href="http://blog.golang.org/profiling-go-programs">Profiling Go Programs</a></li>
</ol>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Golang Frequently Asked Questions (FAQ), <a href="http://golang.org/doc/faq#pass_by_value">When are function parameters passed by value</a>, 引用于2014.01.17.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>The Go Programming Language Specification, <a href="http://golang.org/ref/spec#RangeClause">range clause</a>, version of Nov 13, 2013.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>Go 1 Release Notes, <a href="http://golang.org/doc/go1#deleted">deleted packages</a>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Golang Package Documentation, <a href="http://golang.org/pkg/container/list/#pkg-overview">list package overview</a>.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>
    </div>
    <div id="content-comments">
<!-- Duoshuo Comment BEGIN -->
<div class="ds-thread"></div>
<script type="text/javascript">var duoshuoQuery={short_name:"vic-story"};(function(){var a=document.createElement("script");a.type="text/javascript";a.async=true;a.src=(document.location.protocol=="https:"?"https:":"http:")+"//static.duoshuo.com/embed.js";a.charset="UTF-8";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)})();</script>
<!-- Duoshuo Comment END --></div>

</div>
<div class="niu2-right-container col-md-2">
    <div id="niu2-sidebar-meta" class="niu2-sidebar">
        <div class="niu2-sidebar-label"><i class="fa fa-calendar"></i>发布时间:</div>
        <div class="niu2-sidebar-value">2013-12-25 18:01</div>
        <div class="niu2-sidebar-label"><i class="fa fa-pencil" style="font-size: 1.05em;"></i>最后修改:</div>
        <div class="niu2-sidebar-value">2014-02-20 14:23</div>
        <div class="niu2-sidebar-label"><i class="fa fa-book"></i>分类:</div>
        <div class="niu2-sidebar-value"><a href="http://www.zhuimengle.com/note/index.html">印象-笔记</a></div>
        <div class="niu2-sidebar-label"><i class="fa fa-tag"></i>标签:</div>
 
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="http://www.zhuimengle.com/tag/golang.html">golang</a><sup>4</sup></div>
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="http://www.zhuimengle.com/tag/zong-jie.html">总结</a><sup>13</sup></div>
    </div>
</div>

<div class="niu2-right-container col-md-3">
    <div id="niu2-sidebar-toc" class="niu2-sidebar" data-status="closed">
        <div class="niu2-sidebar-label">
            <i id="niu2-sidebar-toc-ctrl" class="fa fa-plus"></i>目录
        </div>
        <ol id="niu2-sidebar-toc-list">
            <li><a href="#content-heading">Golang学习杂记</a></li>
            <li><a href='#85e90215e2220188b57f612e49a2bf44'>开发环境和工具</a><ol><li><a href='#3867e350ebb33a487c4ac5f7787e1c29'>环境变量</a></li><li><a href='#456f94c1a28382c25e09ff39504347c1'>编译器版本</a></li><li><a href='#8998c0f7f7aefaebad989aef6dfdab25'>辅助工具</a></li></ol></li><li><a href='#c6e79d0b821860da1d6187fac8338d5a'>语法总结</a><ol><li><a href='#488415410b3845655feeefc5207b5c06'>0值</a></li><li><a href='#91414d4d32a791d88b9bec749632987a'>值传递</a></li><li><a href='#7df6e743c28cabad3cac4deba9b16ef5'>引用类型</a></li><li><a href='#ef1465c397cb0afb57238359060065fb'>range表达式</a></li><li><a href='#00684cc251d8c2e4a870aa00128dc1ff'>数组和slice</a><ol><li><a href='#f45a735ab3f170d38481359f09ac511e'>数组类型</a></li><li><a href='#b004d7060310612fc2a5e970bbbbe32d'>slice和数组的定义</a></li><li><a href='#b5d9f3bbb944447754f85a27d68a9ed1'>slice和append</a></li><li><a href='#3b21f3d5af918439f866b01a858c5f00'>slice和数组访问越界</a></li></ol></li><li><a href='#6b46a1cba807f97ed4a145f731fd9cec'>string类型</a></li><li><a href='#1d78dc8ed51214e518b5114fe24490ae'>map</a></li><li><a href='#2cb472ff9cad0c89a033c53996b52053'>初始化</a></li><li><a href='#441add7be9dc2782ccd5f8594f9d0f3c'>赋值操作符</a></li><li><a href='#57e5fba4ce5b4cb9ffd595beb63e7389'>iota</a></li><li><a href='#d3c0b3ea82a4a103b38d5e32d4fb4be2'>函数参数和命名的返回变量</a></li><li><a href='#870a51ba2a9edfadc62ce99af52cabd1'>函数</a></li><li><a href='#68a6605ba63cdd2bd0ef3e5c15dee2ab'>vector容器</a></li><li><a href='#0db23960de47f2f31acde25853062bdf'>返回临时变量的指针</a></li></ol></li><li><a href='#dd970a1f2394462211025da6a66ca504'>标准库</a><ol><li><a href='#ac5c74b64b4b8352ef2f181affb5ac2a'>sql</a></li><li><a href='#4fe3e66b2026c6f3d9514fd8f6cf6668'>gob</a></li><li><a href='#07cc694b9b3fc636710fa08b6922c42b'>time</a></li><li><a href='#10ae9fc7d453b0dd525d0edf2ede7961'>list</a></li></ol></li><li><a href='#80cf5376b8c199b39a1778688720470e'>疑难问题</a><ol><li><a href='#f733ee949a16cd4add143a9c0d13302c'>在循环中删除slice的元素</a></li><li><a href='#c9df09b4610bb43e290507a37c658ae8'>defer</a></li><li><a href='#22a13315ec051c29264322c186236635'>无法获取map元素的地址</a></li><li><a href='#5fc0efe228c120dd03db2c361dd0865b'>for循环变量重复使用问题</a></li></ol></li><li><a href='#3ba34fc6491df1c7ab2d294d7a12417d'>书籍推荐</a><ol><li><a href='#ec1633e5db8e388725ff9d9be144e42c'>Go学习笔记 By雨痕</a></li></ol></li><li><a href='#2053d42c819811d6f43bd3305fe60447'>其他资源</a></li><li><a href='#bf52b411fae5afe9115f14123f776321'>其他问题</a><ol><li><a href='#e7040dd1bcab98d06aa49c5062f122ca'>动态链接</a></li></ol></li><li><a href='#81f5d554d30e82d475ed29a45a7c4277'>阅读资料</a></li>
            <li><a href="#content-comments">评论</a></li>
        </ol>
    </div>
</div>
    </div>

    <div id="body-footer" class="col-md-6 col-md-offset-2">
<div class="niu2-footer">
    <hr/>
	<p>
		Powered by <a href="https://github.com/getpelican/pelican">Pelican</a>, 
        <a href="https://github.com/mawenbao/niu-x2-sidebar">theme</a> built with <a href="http://getbootstrap.com">Bootstrap3</a>
		by <a href="http://blog.atime.me">Ma Wenbao</a>, icons by 
		<a href="http://fortawesome.github.io/Font-Awesome">Font Awesome</a>.
	</p>
	<p>
		©
				2009-2014
		<a class="niu2-footer-link" href="http://www.zhuimengle.com">vk</a>
    </p>
    <p class="niu2-icons">
	        <a class="niu2-footer-icon" href="/my_gnupg.html" title="my public key">
	            <i class="fa fa-key fa-lg"></i>
	        </a>
	        <a class="niu2-footer-icon" href="V: dolphinzhang1987@gmail.com" title="my email address">
	            <i class="fa fa-envelope-o fa-lg"></i>
	        </a>
	        <a class="niu2-footer-icon" href="https://github.com/vickyi" title="my github page">
	            <i class="fa fa-github-alt fa-lg"></i>
	        </a>
	        <a class="niu2-footer-icon" href="/feed.xml" title="subscribe my blog">
	            <i class="fa fa-rss fa-lg"></i>
	        </a>
	</p>
</div>    </div>
    
    <div id="niu2-pygments" data-theme="github"></div>

    <script type="text/javascript" src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="http://www.zhuimengle.com/theme/js/niu2.min.js"></script>
    <script type="text/javascript" src="http://www.zhuimengle.com/theme/js/bootstrap.min.js"></script>
    <script type="text/javascript">onContentLoaded();</script>
  </body>
</html>